// Generated by Apple Swift version 4.2.1 effective-3.4.1 (swiftlang-1000.11.42 clang-1000.11.45.1)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if __has_feature(modules)
@import CoreGraphics;
@import ObjectiveC;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="DrawerController",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class NSCoder;

SWIFT_CLASS("_TtC16DrawerController18AnimatedMenuButton")
@interface AnimatedMenuButton : UIButton
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
@end

@class UIColor;

SWIFT_CLASS("_TtC16DrawerController19DrawerBarButtonItem")
@interface DrawerBarButtonItem : UIBarButtonItem
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithTarget:(id _Nullable)target action:(SEL _Nonnull)action;
- (nonnull instancetype)initWithTarget:(id _Nullable)target action:(SEL _Nonnull)action menuIconColor:(UIColor * _Nonnull)menuIconColor;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end

@class UIGestureRecognizer;
@class UITouch;
@class NSBundle;
@protocol UIViewControllerTransitionCoordinator;

SWIFT_CLASS("_TtC16DrawerController16DrawerController")
@interface DrawerController : UIViewController <UIGestureRecognizerDelegate>
/// The center view controller.
/// This can only be set via the init methods, as well as the <code>setNewCenterViewController:...</code> methods. The size of this view controller will automatically be set to the size of the drawer container view controller, and it’s position is modified from within this class. Do not modify the frame externally.
@property (nonatomic, strong) UIViewController * _Nullable centerViewController;
/// The left drawer view controller.
/// The size of this view controller is managed within this class, and is automatically set to the appropriate size based on the <code>maximumLeftDrawerWidth</code>. Do not modify the frame externally.
@property (nonatomic, strong) UIViewController * _Nullable leftDrawerViewController;
/// The right drawer view controller.
/// The size of this view controller is managed within this class, and is automatically set to the appropriate size based on the <code>maximumRightDrawerWidth</code>. Do not modify the frame externally.
@property (nonatomic, strong) UIViewController * _Nullable rightDrawerViewController;
/// The maximum width of the <code>leftDrawerViewController</code>.
/// By default, this is set to 280. If the <code>leftDrawerViewController</code> is nil, this property will return 0.0;
@property (nonatomic) CGFloat maximumLeftDrawerWidth;
/// The maximum width of the <code>rightDrawerViewController</code>.
/// By default, this is set to 280. If the <code>rightDrawerViewController</code> is nil, this property will return 0.0;
@property (nonatomic) CGFloat maximumRightDrawerWidth;
/// The visible width of the <code>leftDrawerViewController</code>.
/// Note this value can be greater than <code>maximumLeftDrawerWidth</code> during the full close animation when setting a new center view controller;
@property (nonatomic, readonly) CGFloat visibleLeftDrawerWidth;
/// The visible width of the <code>rightDrawerViewController</code>.
/// Note this value can be greater than <code>maximumRightDrawerWidth</code> during the full close animation when setting a new center view controller;
@property (nonatomic, readonly) CGFloat visibleRightDrawerWidth;
/// A boolean that determines whether or not the panning gesture will “hard-stop” at the maximum width for a given drawer side.
/// By default, this value is set to YES. Enabling <code>shouldStretchDrawer</code> will give the pan a gradual asymptotic stopping point much like <code>UIScrollView</code> behaves. Note that if this value is set to YES, the <code>drawerVisualStateBlock</code> can be passed a <code>percentVisible</code> greater than 1.0, so be sure to handle that case appropriately.
@property (nonatomic) BOOL shouldStretchDrawer;
@property (nonatomic) CGFloat drawerDampingFactor;
@property (nonatomic) CGFloat shadowRadius;
@property (nonatomic) float shadowOpacity;
@property (nonatomic) CGFloat bezelRange;
/// The flag determining if a shadow should be drawn off of <code>centerViewController</code> when a drawer is open.
/// By default, this is set to YES.
@property (nonatomic) BOOL showsShadows;
@property (nonatomic) CGFloat animationVelocity;
/// Sets a callback to be called when a gesture has been completed.
/// This block is called when a gesture action has been completed. You can query the <code>openSide</code> of the <code>drawerController</code> to determine what the new state of the drawer is.
/// \param gestureCompletionBlock A block object to be called that allows the implementer be notified when a gesture action has been completed.
///
@property (nonatomic, copy) void (^ _Nullable gestureCompletionBlock)(DrawerController * _Nonnull, UIGestureRecognizer * _Nonnull);
/// Sets a callback to be called to determine if a UIGestureRecognizer should recieve the given UITouch.
/// This block provides a way to allow a gesture to be recognized with custom logic. For example, you may have a certain part of your view that should accept a pan gesture recognizer to open the drawer, but not another a part. If you return YES, the gesture is recognized and the appropriate action is taken. This provides similar support to how Facebook allows you to pan on the background view of the main table view, but not the content itself. You can inspect the <code>openSide</code> property of the <code>drawerController</code> to determine the current state of the drawer, and apply the appropriate logic within your block.
/// Note that either <code>openDrawerGestureModeMask</code> must contain <code>OpenDrawerGestureModeCustom</code>, or <code>closeDrawerGestureModeMask</code> must contain <code>CloseDrawerGestureModeCustom</code> for this block to be consulted.
/// \param gestureShouldRecognizeTouchBlock A block object to be called to determine if the given <code>touch</code> should be recognized by the given gesture.
///
@property (nonatomic, copy) BOOL (^ _Nullable gestureShouldRecognizeTouchBlock)(DrawerController * _Nonnull, UIGestureRecognizer * _Nonnull, UITouch * _Nonnull);
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
/// Creates and initializes an <code>DrawerController</code> object with the specified center view controller, left drawer view controller, and right drawer view controller.
/// \param centerViewController The center view controller. This argument must not be <code>nil</code>.
///
/// \param leftDrawerViewController The left drawer view controller.
///
/// \param rightDrawerViewController The right drawer controller.
///
///
/// returns:
/// The newly-initialized drawer container view controller.
- (nonnull instancetype)initWithCenterViewController:(UIViewController * _Nonnull)centerViewController leftDrawerViewController:(UIViewController * _Nullable)leftDrawerViewController rightDrawerViewController:(UIViewController * _Nullable)rightDrawerViewController OBJC_DESIGNATED_INITIALIZER;
/// Creates and initializes an <code>DrawerController</code> object with the specified center view controller, left drawer view controller.
/// \param centerViewController The center view controller. This argument must not be <code>nil</code>.
///
/// \param leftDrawerViewController The left drawer view controller.
///
///
/// returns:
/// The newly-initialized drawer container view controller.
- (nonnull instancetype)initWithCenterViewController:(UIViewController * _Nonnull)centerViewController leftDrawerViewController:(UIViewController * _Nullable)leftDrawerViewController;
/// Creates and initializes an <code>DrawerController</code> object with the specified center view controller, right drawer view controller.
/// \param centerViewController The center view controller. This argument must not be <code>nil</code>.
///
/// \param rightDrawerViewController The right drawer controller.
///
///
/// returns:
/// The newly-initialized drawer container view controller.
- (nonnull instancetype)initWithCenterViewController:(UIViewController * _Nonnull)centerViewController rightDrawerViewController:(UIViewController * _Nullable)rightDrawerViewController;
- (void)encodeRestorableStateWithCoder:(NSCoder * _Nonnull)coder;
- (void)decodeRestorableStateWithCoder:(NSCoder * _Nonnull)coder;
@property (nonatomic, readonly, strong) UIViewController * _Nullable childViewControllerForStatusBarHidden;
@property (nonatomic, readonly, strong) UIViewController * _Nullable childViewControllerForStatusBarStyle;
/// Sets the maximum width of the left drawer view controller.
/// If the drawer is open, and <code>animated</code> is YES, it will animate the drawer frame as well as adjust the center view controller. If the drawer is not open, this change will take place immediately.
/// \param width The new width of left drawer view controller. This must be greater than zero.
///
/// \param animated Determines whether the drawer should be adjusted with an animation.
///
/// \param completion The block called when the animation is finished.
///
- (void)setMaximumLeftDrawerWidth:(CGFloat)width animated:(BOOL)animated completion:(void (^ _Nullable)(BOOL))completion;
/// Sets the maximum width of the right drawer view controller.
/// If the drawer is open, and <code>animated</code> is YES, it will animate the drawer frame as well as adjust the center view controller. If the drawer is not open, this change will take place immediately.
/// \param width The new width of right drawer view controller. This must be greater than zero.
///
/// \param animated Determines whether the drawer should be adjusted with an animation.
///
/// \param completion The block called when the animation is finished.
///
- (void)setMaximumRightDrawerWidth:(CGFloat)width animated:(BOOL)animated completion:(void (^ _Nullable)(BOOL))completion;
/// Sets the new <code>centerViewController</code>.
/// This sets the view controller and will automatically adjust the frame based on the current state of the drawer controller. If <code>closeAnimated</code> is YES, it will immediately change the center view controller, and close the drawer from its current position.
/// \param centerViewController The new <code>centerViewController</code>.
///
/// \param closeAnimated Determines whether the drawer should be closed with an animation.
///
/// \param completion The block called when the animation is finsihed.
///
- (void)setCenter:(UIViewController * _Nonnull)newCenterViewController withCloseAnimation:(BOOL)animated completion:(void (^ _Nullable)(BOOL))completion;
/// Sets the new <code>centerViewController</code>.
/// This sets the view controller and will automatically adjust the frame based on the current state of the drawer controller. If <code>closeFullAnimated</code> is YES, the current center view controller will animate off the screen, the new center view controller will then be set, followed by the drawer closing across the full width of the screen.
/// \param newCenterViewController The new <code>centerViewController</code>.
///
/// \param fullCloseAnimated Determines whether the drawer should be closed with an animation.
///
/// \param completion The block called when the animation is finsihed.
///
- (void)setCenter:(UIViewController * _Nonnull)newCenterViewController withFullCloseAnimation:(BOOL)animated completion:(void (^ _Nullable)(BOOL))completion;
- (void)toggleLeftDrawerSideWithAnimated:(BOOL)animated completion:(void (^ _Nullable)(BOOL))completion;
- (void)toggleRightDrawerSideWithAnimated:(BOOL)animated completion:(void (^ _Nullable)(BOOL))completion;
/// Closes the open drawer.
/// \param animated Determines whether the drawer side should be closed animated
///
/// \param completion The block that is called when the close is complete
///
- (void)closeDrawerWithAnimated:(BOOL)animated completion:(void (^ _Nullable)(BOOL))completion;
- (void)viewDidLoad;
- (void)viewWillAppear:(BOOL)animated;
- (void)viewDidAppear:(BOOL)animated;
- (void)viewWillDisappear:(BOOL)animated;
- (void)viewDidDisappear:(BOOL)animated;
@property (nonatomic, readonly) BOOL shouldAutomaticallyForwardAppearanceMethods;
@property (nonatomic, readonly) BOOL shouldAutorotate;
@property (nonatomic, readonly) UIInterfaceOrientationMask supportedInterfaceOrientations;
- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator> _Nonnull)coordinator;
- (BOOL)gestureRecognizer:(UIGestureRecognizer * _Nonnull)gestureRecognizer shouldReceiveTouch:(UITouch * _Nonnull)touch SWIFT_WARN_UNUSED_RESULT;
@end

@class UIStoryboardSegue;

@interface DrawerController (SWIFT_EXTENSION(DrawerController))
- (void)awakeFromNib;
- (void)prepareForSegue:(UIStoryboardSegue * _Nonnull)segue sender:(id _Nullable)sender;
@end


SWIFT_CLASS("_TtC16DrawerController11DrawerSegue")
@interface DrawerSegue : UIStoryboardSegue
- (void)perform;
- (nonnull instancetype)initWithIdentifier:(NSString * _Nullable)identifier source:(UIViewController * _Nonnull)source destination:(UIViewController * _Nonnull)destination OBJC_DESIGNATED_INITIALIZER;
@end




@interface UIViewController (SWIFT_EXTENSION(DrawerController))
@property (nonatomic, readonly, strong) DrawerController * _Nullable evo_drawerController;
@property (nonatomic, readonly) CGRect evo_visibleDrawerFrame;
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
